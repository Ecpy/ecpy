# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright 2015 by Ecpy Authors, see AUTHORS for more details.
#
# Distributed under the terms of the BSD license.
#
# The full license is in the file LICENCE, distributed with this software.
# -----------------------------------------------------------------------------
"""Widgets dedicated to edit the tools attached to a measure.

"""
from __future__ import (division, unicode_literals, print_function,
                        absolute_import)

from traceback import format_exc

from enaml.widgets.api import (DockItem, Notebook, Page, Dialog, PushButton,
                               Container)
from enaml.layout.api import hbox, vbox, spacer
from enaml.core.api import Declarative

from ...utils.enaml_destroy_hook import add_destroy_hook
from ...utils.widgets.qt_list_str_widget import QtListStrWidget


enamldef ToolSelector(Dialog): dial:
    """ Simple dialog to select a tool.

    """
    #: Kind of tool to select ({'pre-hook', 'monitor', 'post-hook'})
    attr kind

    #: Measure for which a new tool is being chosen.
    attr measure

    #: Declaration for the currently selected tool.
    attr selected_decl

    #: Private version of kind, reflecting the real name of the members
    attr _kind = kind.replace('-', '_')+'s'

    title = 'Select a %s' % kind

    Container:
        constraints << [vbox(list_ed, desc, hbox(cancel, ok))]

        QtListStrWidget: list_ed:
            items << getattr(measure.plugin, _kind)
            selected_item::
                new = change['value']
                if new:
                    pl = measure.plugin
                    dial.selected_decl = pl.get_declarations(_kind, [new])

        MultilineField: desc:
            text << selected_decl.description if selected_decl else ''

        PushButton: ok:
            text = 'Ok'
            enabled << bool(dial.selected_decl)
            clicked ::
                dial.accept()

        PushButton: cancel:
            text = 'Cancel'
            clicked ::
                dial.reject()


enamldef NonEditableTool(Container):
    """Widget used when the make_view method of the tool declaration return
    None

    """
    #: Reference to the tool to which this view is linked.
    attr tool

    Label:
        text = 'Tool %s is not editable' % tool.declaration.id

    MultilineField:
        read_only = True
        text = tool.declaration.description


DestroyableContainer = add_destroy_hook(Container)

enamldef ToolsEditor(DestroyableContainer): main:
    """Widget used to edit the tools parameters of a measure.

    """
    #: Kind of tool to edit ({'pre-hook', 'monitor', 'post-hook'})
    attr kind

    #: Measure whose tools are being edited.
    attr measure

    #: Currently selected tool (id)
    alias selected_id : tools.selected_item

    #: Cache of the already created views.
    attr _cache = {}

    #: Private version of kind, reflecting the real name of the members
    attr _kind = kind.replace('-', '_')+'s'

    constraints << [hbox(nb, vbox(add, remove, spacer))]

    func update_items(change):
        """Update the list of tools.

        """
        tools.items = list(getattr(measure, _kind))

    func make_view(selected):
        """Create (or retrieve from the cache) a view for the selected tool.
        """
        if selected in _cache:
            return _cache[selected]

        tool = getattr(measure, _kind)[selected]
        decl = tool.declarations
        view = decl.make_view(measure.plugin.workbench, tool)
        if not view:
            view = NonEditableTool(tool=tool)
        _cache[selected] = view
        return view

    initialized ::
        update_items(None)
        measure.observe(_kind, update_items)

    ended ::
        for w in _cache.values():
            w.set_parent(None)
            w.destroy()

    QtListStrWidget: tools:
        sort = False
        selected ::
            if 'oldvalue' in change:
                change['oldvalue'].set_parent(None)
            view = make_view(change['value'])
            view.set_parent(cont)
            view.show()

    Declarative: cont:
        pass

    PushButton: add:
        text = 'Add'
        enabled << not all([id in tools.items
                            for id in  getattr( measure.plugin, _kind)
        clicked ::
            selector = ToolSelector(measure=measure, kind=kind)
            if selector.exec_():
                workbench = measure.plugin.workbench
                tool_id = selector.selected_decl.id
                try:
                    measure.add_tool(kind, tool_id)
                except Exception:
                    w = measure.plugin.workbench
                    core = w.get_plugin('enaml.workbench.core')
                    cmd = 'ecpy.app.errors.signal'
                    msg = 'Failed to create/add %s %s :\n%s'
                    err = format_exc()
                    core.invoke_command(cmd,
                                        dict(kind='error',
                                             message=msg % (kind, tool_id,err))
                                        )

    PushButton: remove:
        text = 'Remove'
        enabled << bool(selected_id)
        clicked ::
            try:
                measure.remove_tool(selected_id)
            except KeyError:
                pass
            if selected_id in _cache:
                view = _cache[selected_id]
                view.set_parent(None)
                view.destroy()
                del _cache[selected_id]

    PushButton: up:
        text = 'Move up'
        enabled << bool(selected_id) and selected_id != tools.items[0]
        clicked ::
            ind = tools.items.index(selected_id)
            measure.move_tool(kind, ind, ind-1)

    PushButton: down:
        text = 'Move down'
        enabled << bool(selected_id) and selected_id != tools.items[-1]
        clicked ::
            ind = tools.items.index(selected_id)
            measure.move_tool(kind, ind, ind+1)


enamldef ToolsEditorDockItem(DockItem): main:
    """DockItem for editing the tools attached to a measure.

    """
    # Measure whose tools are being edited.
    attr measure

    title = 'Measure tools'

    Notebook:
        tabs_closable = False
        tabs_movable = False

        Page:
            title = 'Pre-execution'
            Container:
                constraints << [hbox(pre_ed, spacer)]
                ToolsEditor: pre_ed:
                    kind = 'pre_hook'
                    measure << main.measure

        Page:
            title = 'Monitors'
            Container:
                constraints << [hbox(mon_ed, spacer)]
                MonitorsEditor: mon_ed:
                    kind = 'monitor'
                    measure << main.measure

        Page:
            title = 'Post-execution'
            Container:
                constraints << [hbox(post_ed, spacer)]
                PostHooksEditor: post_ed:
                    kind = 'post_hook'
                    measure << main.measure
