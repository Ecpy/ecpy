# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright 2015 by Ecpy Authors, see AUTHORS for more details.
#
# Distributed under the terms of the BSD license.
#
# The full license is in the file LICENCE, distributed with this software.
# -----------------------------------------------------------------------------
"""Dummy contributions to the measure plugin used for testing purposes.

"""
from __future__ import (division, unicode_literals, print_function,
                        absolute_import)

from enaml.workbench.api import PluginManifest, Extension
from ecpy.app.dependencies.api import BuildDependency, RuntimeDependency
from ecpy.measure.editors.api import Editor
from ecpy.measure.hooks.api import PreExecutionHook, PostExecutionHook
from ecpy.measure.engines.api import Engine
from ecpy.measure.monitors.api import Monitor

class Flags(object):

    BUILD_FAIL_ANALYSE = False

    BUILD_FAIL_COLLECT = False

    RUNTIME1_FAIL_ANALYSE = False

    RUNTIME2_FAIL_ANALYSE = False

    RUNTIME_UNAVAILABLE = False

    RUNTIME_FAIL_COLLECT = False


enamldef MeasureTestManifest(PluginManifest):
    """Manifest contributing dummy extensions to measure plugin.

    """
    Extension:
        id = 'editor'
        point = 'ecpy.measure.editors'
        Editor:
            id = 'dummy'
            description = 'This is a dummy'
            new => (workbench, default=True):
                from .dummies import DummyEditor
                return DummyEditor(declaration=self)

            is_meant_for => (workbench, selected_task):
                return True

    Extension:
        id = 'engines'
        point = 'ecpy.measure.engines'
        Engine:
            id = 'dummy'
            description = 'This is a dummy'

            attr selected
            attr workspace_contributing
            new => (workbench, default=True):
                from .dummies import DummyEngine
                return DummyEngine(declaration=self)

            react_to_selection => (workbench):
                self.selected = True

            react_to_unselection => (workbench):
                self.selected = False

            contribute_to_workspace => (workspace):
                self.workspace_contributing = True

            clean_workspace => (workspace):
                self.workspace_conytributing = False

    Extension:
        id = 'pre-hook'
        point = 'ecpy.measure.pre-execution'
        PreExecutionHook:
            id = 'dummy'
            description = 'This is a dummy'
            new => (workbench, default=True):
                from .dummies import DummyPreHook
                return DummyPreHook(declaration=self)

    Extension:
        id = 'monitors'
        point = 'ecpy.measure.monitors'
        Monitor:
            id  = 'dummy'
            description = 'This is a dummy'
            new => (workbench, default=True):
                from .dummies import DummyMonitor
                return DummyMonitor(declaration=self)

    Extension:
        id = 'post-hook'
        point = 'ecpy.measure.post-execution'
        PostExecutionHook:
            id = 'dummy'
            description = 'This is a dummy'
            new => (workbench, default=True):
                from .dummies import DummyPostHook
                return DummyPostHook(declaration=self)

    Extension:
        id = 'build-dep'
        point = 'ecpy.app.dependencies.build'
        BuildDependency:
            id = 'dummy'
            analyse => (workbench, obj, getter, dependencies, errors):
                if Flags.BUILD_FAIL_ANALYSE:
                    raise Exception()
                else:
                    dependencies.add('test')
                    return ['dummy1']
            collect => (workbench, dependencies, errors):
                if Flags.BUILD_FAIL_COLLECT:
                    raise Exception()
                else:
                    dependencies['test'] = 1

    Extension:
        id = 'runtime-dep'
        point = 'ecpy.app.dependencies.runtime'
        RuntimeDependency:
            id = 'dummy1'
            analyse => (workbench, obj, getter, dependencies, errors):
                if Flags.RUNTIME1_FAIL_ANALYSE:
                    raise Exception()
                else:
                    dependencies.add('test')
            collect => (workbench, owner, dependencies, unavailable, errors):
                if Flags.RUNTIME_FAIL_COLLECT:
                    raise Exception()
                elif Flags.RUNTIME_UNAVAILABLE:
                    unavailable.add('test')
                else:
                    dependencies['test'] = 1
            release => (workbench, owner, dependencies):
                if 'test' in dependencies:
                    dependencies['test'] = None

    Extension:
        id = 'runtime-dep2'
        point = 'ecpy.app.dependencies.runtime'
        RuntimeDependency:
            id = 'dummy2'
            collect => (workbench, owner, dependencies, unavailable, errors):
                if Flags.RUNTIME_FAIL_COLLECT:
                    raise Exception()
                else:
                    dependencies['test'] = 1
            release => (workbench, owner, dependencies):
                if 'test' in dependencies:
                    dependencies['test'] = None
