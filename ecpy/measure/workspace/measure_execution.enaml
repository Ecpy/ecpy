# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright 2015 by Ecpy Authors, see AUTHORS for more details.
#
# Distributed under the terms of the BSD license.
#
# The full license is in the file LICENCE, distributed with this software.
# -----------------------------------------------------------------------------
"""Workspace used for editing and executing measures.

"""
from __future__ import (division, unicode_literals, print_function,
                        absolute_import)

import os

from enaml.core.api import Looper, Conditional
from enaml.layout.api import hbox, spacer, vbox, factory
from enaml.widgets.api import (PushButton, Menu, Action, Container, CheckBox,
                               DockItem, Label, GroupBox)
from enaml.stdlib.message_box import question


from ...utils.widgets.list_editor import ListEditor
from ...utils.widgets.qt_list_str_widget import QtListStrWidget
from ..engines.selection import EngineSelector
from .measure_edition import MeasureEditorDialog

enamldef MeasView(GroupBox): widget:
    """Simple visual summary of a measure.

    """
    #: Refrence to the measure driving this view.
    attr model

    title << measure.name

    layout_constraints => ():
        meas = widget.model
        children = widget.visible_widgets()
        if meas.status == 'READY':
            return [vbox(hbox(children[0], children[1], spacer),
                         hbox(children[2], spacer, children[3]))]
        elif meas.status not in ('READY', 'RUNNING'):
            return [vbox(hbox(children[0], children[1], spacer),
                         children[2])]
        else:
            return [hbox(children[0], children[1], spacer)]

    Label:
        text = 'Status :'
    Label:
        text << model.status
        tool_tip << model.infos

    Conditional: cd1:
        condition << bool(model.status in ('READY', 'EDITING'))
        PushButton: edit:
            text = 'Edit'
            clicked ::
                kwargs = {'parent': widget, 'measure': measure,
                          'workspace': measure.plugin.workspace}
                meas_editor = MeasureEditorDialog(**kwargs)
                model.status = 'EDITING'
                meas_editor.exec_()

                model.status = 'READY'

        PushButton: process:
            text = 'Process'
            enabled << not workspace.plugin.processor.active
            clicked ::
                model.plugin.workspace.process_single_measure(model)

    Conditional: cd2:
        condition << bool(model.status not in ('READY', 'RUNNING',
                                               'EDITING'))
        PushButton:
            text = 'Re-enqueue'
            clicked::
                model.plugin.workspace.reenqueue_measure(model)


def label_maker(running, paused):
    """ Helper determining the proper label for the start button.

    """
    if not running:
        return 'Start'
    else:
        if paused:
            return 'Resume'
        else:
            return 'Pause'


enamldef ExecutionDockItem(DockItem):
    """Dock item presenting the currently enqueued measures.

    """
    #: Refrence to the measure workspace.
    attr workspace

    closable = False
    name = 'meas_exec'
    title = 'Enqueued measures'

    func move_measure(old, new):
        workspace.plugin.enqueued_measures.move(old, new)

    func remove_measure(index):
        measure = workspace.plugin.enqueued_measures[index]
        workspace.plugin.enqueued_measures.remove(measure)

    Container:
        constraints << [vbox(ed,
                             hbox(start, stop, spacer, mon),
                             hbox(clean, spacer, proc_all),
                             en)]

        ListEditor(MeasView): ed:
            ed.model = workspace.plugin
            ed.iterable_name = 'enqueued_measures'
            ed.signal_name = 'enqueued_measures_changed'
            ed.operations = {'move': move_measure,
                             'remove': remove_measure}

        PushButton: start:
            #: Flag indicating the measure is running.
            attr running << workspace.plugin.processor.active

            #: Flag indicating the measure is in the process of pausing.
            attr pausing << running and\
                workspace.plugin.running_measure.status == 'PAUSING'

            #: Flag indicating the measure is in pause.
            attr paused << running and\
                workspace.plugin.running_measure.status == 'PAUSED'

            text << label_maker(running, paused)
            enabled << bool(workspace.plugin.enqueued_measures) and not pausing

            clicked ::
                if not running:
                    workspace.start_processing_measures()
                else:
                    if paused:
                        workspace.resume_current_measure()
                    else:
                        workspace.pause_current_measure()

        PushButton: stop:
            attr stopping << \
                workspace.plugin.running_measure.status == 'STOPPING'
            text = 'Stop' if not stopping else 'Force stop'
            enabled << 'processing' in workspace.plugin.flags

            func should_process_all():
                if not workspace.plugin.processor.continuous_processing:
                    return

                if not workspace.plugin.find_next_measure():
                    return

                res = question(parent=stop,
                               title='Should process following measures ?',
                               text=('Do you want to process the next '
                                     'measures in the queue ?'))
                if not res or res.text == 'No':
                    workspace.plugin.processor.continue_processing = False

            Menu:
                Action:
                    text = 'Skip post execution'
                    triggered ::
                        workspace.stop_current_measure(no_post_exec=True,
                                                       force=stopping)

                            should_process_all()
                Action:
                    text = 'Run post execution'
                    triggered ::
                        workspace.stop_current_measure(force=stopping)
                        if workspace.plugin.processor.continuous_processing:
                            should_process_all()

        CheckBox: proc_all:
            text = 'Process all'
            tool_tip = ('When checked all measures in the queue are processed '
                        'in order otherwise execution will stop at the end of '
                        'the execution of the currently/next executed measure.'
                        )
            checked := workspace.plugin.processor.continuous_processing

        PushButton: clean:
            text = 'Clean'
            tool_tip = 'Remove all measure which have already been processed'
            enabled << (bool(workspace.plugin.enqueued_measures) and
                        not workspace.plugin.processor.active)
            clicked ::
                workspace.remove_processed_measures()

        PushButton: mon:
            text = 'Show monitors'
            enabled << workspace.plugin.processor.monitors_window
            clicked::
                window = workspace.plugin.processor.monitors_window
                window.show()
                window.restore()
                window.send_to_front()

        GroupBox: en:
            attr proc = workspace.plugin.processor
            title = 'Engine'
            visible << bool(proc.engine)

            constraints = [hbox(en_st, en_st_val, en_sh]

            Label: en_st:
                text = 'Status'

            Field: en_st_val:
                text << proc.engine.status if proc.engine else ''
                read_only = True

            PushButton: en_sh:
                text = 'Shutdown'
                tool_tip = ('Completetly stop the engine used to perform '
                            'measure.')
                enabled << not proc.active and proc.engine.status != 'Stopped'
