# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright 2015-2016 by Ecpy Authors, see AUTHORS for more details.
#
# Distributed under the terms of the BSD license.
#
# The full license is in the file LICENCE, distributed with this software.
# -----------------------------------------------------------------------------
"""Widgets used to edit an instrument profile.

"""
from __future__ import (division, unicode_literals, print_function,
                        absolute_import)

from configobj import ConfigObj
from atom.api import Coerced, Bool
from enaml.validator import Validator
from enaml.layout.api import hbox, vbox, spacer
from enaml.widgets.api import (Notebook, Page, Label, Field, PushButton,
                               Dialog, MultilineField, ObjectCombo, Form,
                               PopupView)

from ...utils.widgets.qt_list_str_widget import QtListStrWidget
from ...utils.transformers import ids_to_unique_names
from ...utils.enaml_destroy_hook import add_destroy_hook
from .instrument_selection import ModelSelectionDialog


class SetValidator(Validator):
    """Validator allowing names which does not yet exist.

    """
    #: Already existing names which are then not allowed.
    existing = Coerced(set)

    #: Flag indicating whether or not the last validation went right
    valid = Bool(True)

    def validate(self, text):
        """Check that the name does yet exist.

        """
        res = text not in self.existing
        self.valid = res
        return res


enamldef ConnectionCreationDialog(Dialog): dial:
    """Dialog allowing the user to select the connection to add to the profile.

    """
    #: Reference to the instrument plugin
    attr plugin

    #: Instrument model infos for which to create the connection
    attr model_infos

    #: Already existing connections (ids) for the profile.
    attr existing

    #: Currently selected connection declaration.
    attr connection

    func create_connection():
        """Create the connection editor corresponding to selected connection.

        """
        c_id = items[selected_item]
        infos = model_infos.connections[selected_item]
        self.connection = plugin.create_connection(c_id, infos)

    initialized ::
        create_connection()

    Container:

        constraints = [vbox(hbox(conns, vbox(lab, desc, spacer)),
                            hbox(spacer, can, ok))]

        QtListStrWidget: conns:
            items = ids_to_unique_names([c for c in model_infos.connections
                                         if c not in existing])
            selected_item ::
                create_connection()

        Label: lab:
            text << connection.declaration.id if connection else ''

        MultilineField: desc:
            text << connection.declaration.description if connection  else ''

        PushButton: can:
            text = 'Cancel'
            clicked ::
                dial.reject()

        PushButton: ok:
            text = 'Ok'
            clicked ::
                dial.accept()


enamldef ConnectionValidationWindow(Window): dial:
    """Dialog allowing the user to test that the provided information allow to
    open the connection.

    """
    #: Reference to the instrument plugin.
    attr plugin = editor.plugin

    #: Reference to the editor that opened this window.
    attr editor

    #: Profile infos that should be tested.
    attr profile_infos = editor.profile_infos

    #: Currently selected driver id.
    attr driver = profile_infos.model.drivers[0]

    #: Currently selected connection.
    attr connection = profiles_infos.connections[0]

    #: Currently selected settings.
    attr settings = (profile_infos.settings[0] if profile_infos.settings
                     else None)

    Container:

        constraints = []

        Form:
            Conditional:
                condition = len(profile_infos.model.drivers) > 1
                attr d_map = {'%s <%s>' % (d.infos['architecture'], d.id): d
                              for d in profile_infos.model.drivers}
                Label: dri_lab:
                    text = 'Driver'
                ObjectCombo: driver_impl:
                    items = list(d_map)
                    tool_tip = 'What driver should be used for testing.'
                    selected_item ::
                        dial.driver = d_map[selected_item]

            Label: conn_lab:
                text='Connection'
            ObjectCombo: conn:
                items = profile_infos.connection
                tool_tip = 'Connection informations to use for the test.'
                selected_item >> dial.connection

            Conditional:
                condition = bool(profile_infos.settings)
                Label: sett_lab:
                    text = 'Settings'
                ObjectCombo: sett:
                    items = profile_infos.settings
                    tool_tip = 'Select the settings to use during the test.'

        PushButton: test:
            text = 'Test connection'
            clicked ::
                editor.sync()
                driver, starter = plugin.get_drivers([driver])[driver.id]
                c = profile_infos.get_connection(connection)
                s = profille_infos.get_settings(settings) if settings else {}
                res, msg = starter.check_infos(driver, c, d)
                m = ('The connection was successfully established' if res else
                     'An error occured:\n' + msg)
                infos.text += '\n' + m

        MultilineField: infos:
            Menu:
                context = True
                Action:
                    text = 'Clear'
                    triggered :: infos.text = ''

        PushButton:
            text = 'Close'
            clicked ::
                dial.accept()


enamldef SettingsCreationDialog(Dialog):
    """Dialog allowing the user to select the settings to add to the profile.

    """
    #: Reference to the instrument plugin
    attr plugin

    #: Instrument model infos for which to create the settings
    attr model_infos

    #: Already existing settings (name) for the profile.
    attr existing

    #: Settings instance to insert.
    attr settings

    func create_settings():
        s_id = items[selected_item]
        infos = model_infos.settings[selected_item]
        dial.settings = plugin.create_settings(s_id, infos)

    initialized ::
        create_settings()

    Container:

        constraints = [vbox(hbox(conns, vbox(lab, desc,
                                             hbox(n_lab, n_val), spacer)),
                            hbox(spacer, can, ok))]

        QtListStrWidget: conns:
            items = ids_to_unique_names(model_infos.settings)
            selected_item ::
                create_settings()

        Label: lab:
            text << settings.declaration.id if settings else ''

        MultilineField: desc:
            text << settings.declaration.description if settings  else ''

        Label: n_lab:
            text = 'Name'
        Field: n_val:
            submit_triggers = ['auto_sync']
            validator = SetValidator(existing=existing)

        PushButton: can:
            text = 'Cancel'
            clicked ::
                dial.reject()

        PushButton: ok:
            text = 'Ok'
            enabled << n_val.text and n_val.validator.valid
            clicked ::
                settings.name = n_val.name
                dial.accept()


enamldef RenameSettingsPopup(PopupView): pop:
    """PopupView to rename a settings.

    """
    #: Settings editor whose name should be modified.
    attr settings

    #: Names of the other existing settings editor.
    attr existing

    window_type = 'popup'

    close_on_click = False

    Container:

        constraints = [vbox(hbox(n_lab, n_val), hbox(spacer, can, ok))]

        Label: n_lab:
            text = 'Name'
        Field: n_val:
            hug_width = 'ignore'
            text = settings.name
            validator = SetValidator(existing=existing)
        PushButton: can:
            text = 'Cancel'
            clicked ::
                pop.close()
        PushButton: ok:
            enabled << n_val.text and n_val.validator.valid
            text = 'Ok'
            clicked ::
                settings.name = n_val.text
                pop.close()


enamldef ProfileEditionWidget(add_destroy_hook(Container)): main:
    """Widget dedicated to editing a profile.

    """
    #: Reference to the instrument plugin.
    attr plugin

    #: ProfileInfos driving this widget. Not that the infos are not kept in
    #: sync at all time and one should call sync before inspecting the content
    #: of the member.
    attr profile_infos

    #: Connections editors opened.
    alias connections : cons.items

    #: Settings editors opened.
    alias settings : setts.items

    #: Prevent edition while allowing to navigate the notebooks.
    attr read_only : bool = False

    #: Private reference to the connection validator window which is closed
    #: when this widget is destroyed.
    attr _validator

    func sync():
        """Synchronize the UI with the underlying model.

        This is needed to update the connections and settings.

        """
        cs = profile_infos._config['connections']
        cs.clear()
        for c in connections:
            cs[c.declaration.id] = c.gather_infos()

        sts = profile_infos._config['settings']
        sts.clear()
        for s in settings:
            cs[s.name] = s.gather_infos()

    initialized ::
        profile = profile._config
        id_val.text = profile['id']
        main.model_info = plugin.get_model_info(profile['model_id'])
        for k, v in profile.get('connections', {}).items():
            plugin.create_connection(k, v)

        for k, v in profile.get('settings', {}).items():
            plugin.create_settings(k, v)

    ended ::
        if self._validator and self._validator.visible:
            self._validator.close()

    constraints = [vbox(hbox(id_lab, id_val),
                        hbox(model_lab, model, m_choose),
                        *nb.items]

    Label: id_lab:
        text = 'Id'
    Field: id_val:
        text := profile_infos.id
        validator << SetValidator(existing=plugin.profiles)
        enabled = not read_only

    Label: model_lab:
        text = 'Instrument'
    Field: model:
        text << profile_infos.model.id if profile_infos.model else ''
        read_only = True
    PushButton: m_choose:
        text = 'Choose'
        visible = not read_only
        clicked ::
            dial = ModelSelectionDialog(parent=self, plugin=plugin,
                                        model=profile_infos.model)
            if dial.exec_():
                new = dial.model
                main.connections = [c for c in main.connections
                                    if c.declaration.id in new.connections]
                main.settings = [s for s in main.settings
                                 if s in s.declaration.id in new.settings]
                main.profile_infos.model = new

    Conditional: nb:
        condition << bool(profile_infos.model)

        Notebook:
            tabs_closable = False
            tabs_movable = False
            Page:
                title = 'Connections'
                Container:

                    constraints = ([hbox(conns, *(tuple(s_conn.objects) +
                                                  (vbox(add_c, del_c, val_c,
                                                        spacer))))]
                                   if not read_only else
                                   [hbox(conns, *(tuple(s_conn.objects) +
                                                  (vbox(val_c, spacer))))])

                    QtListStrEditor: conns:
                        sort = False
                        to_string = lambda c: c.title
                    Include: s_conn:
                        destroy_old = False
                        objects << (conns.selected_item if conns.selected_item
                                    else [Container()])
                    PushButton: add_c:
                        text = 'Add'
                        enabled << (set(connections) !=
                                    set(profile_infos.model.connections))
                        visible = not read_only
                        clicked ::
                            kw = {'plugin': plugin,
                                  'model_info': profile_infos.model,
                                  'existing': [c.declaration.id
                                               for c in connections]}
                            dial = ConnectionCreationDialog(**kw)
                            dial.exec_()
                            if dial.connection:
                                dial.connection.read_only = read_only
                                main.connections = (main.connections[:] +
                                                    [dial.connection])
                                conns.selected_item = dial.connection
                    PushButton: del_c:
                        text = 'Delete'
                        enabled << bool(connections)
                        visible = not read_only
                        clicked ::
                            s = main.connections[:]
                            del s[self.selected_index]
                            main.connections = s
                    PushButton: val_c:
                        text = 'Validate'
                        enabled << (not self._validator or
                                    not self._validator.visible)
                        clicked ::
                            selected = conns.selected_item
                            d = ConnectionValidationWindow(editor=main,
                                                           connection=selected)
                            d.show()
                            self._validator = d

            Page:
                title = 'Settings'
                Container:

                    constraints = ([hbox(setts, *(tuple(s_sett.objects) +
                                                  (vbox(add_s, re_s, del_s))))]
                                   if not read_only else
                                   [hbox(setts, *s_sett.objects)])

                    QtListStrEditor: setts:
                        sort = False
                        to_string = lambda s: s.name
                    Include: s_sett:
                        destroy_old = False
                        objects << (setts.selected_item if setts.selected_item
                                    else [Container()])
                    PushButton: add_s:
                        text = 'Add'
                        visible = not read_only
                        clicked ::
                            kw = {'plugin': plugin,
                                  'model_info': profile_infos.model,
                                  'existing': [s.name for s in settings]}
                            dial = SettingsCreationDialog(**kw)
                            dial.exec_()
                            if dial.settings:
                                dial.settings.read_only = read_only
                                main.settings = (main.settings[:] +
                                                 [dial.settings])
                                conns.selected_item = dial.settings
                    PushButton: re_s:
                        text = 'Rename'
                        enabled << bool(setts.selected_item)
                        visible = not read_only
                        clicked ::
                            s = setts.selected_item
                            others = set(s.name for s in settings)
                            others.remove(s.name)
                            popup = RenameSettingsPopup(parent=self,
                                                        settings=s,
                                                        existing=others)
                            popup.show()
                    PushButton: del_s:
                        text = 'Delete'
                        visible = not read_only
                        clicked ::
                            s = main.settings[:]
                            del s[self.selected_index]
                            main.settings = s


enamldef ProfileEditionDialog(Dialog): dial:
    """Dialog allowing to edit a profile infos.

    """
    #: Reference to the instrument plugin.
    alias plugin : ed.plugin

    #: ProfileInfos to edit.
    alias profile_infos : ed.profile_infos

    Container:

        constraints = [vbox(ed, hbox(spacer, can, ok))]

        ProfileEditionWidget: ed:
            pass

        PushButton: can:
            text = 'Cancel'
            clicked ::
                dial.reject()

        PushButton: ok:
            text = 'Ok'
            clicked ::
                ed.sync()
                dial.accept()
