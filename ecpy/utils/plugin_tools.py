# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright 2015 by Ecpy Authors, see AUTHORS for more details.
#
# Distributed under the terms of the BSD license.
#
# The full license is in the file LICENCE, distributed with this software.
# -----------------------------------------------------------------------------
"""Useful tools to avoid code duplication when writing plugins.

"""
from __future__ import (division, unicode_literals, print_function,
                        absolute_import)

from collections import defaultdict
from atom.api import Atom, Dict, Unicode, Value, Typed, Callable
from enaml.workbench.api import Workbench, Plugin

from .atom_util import (update_members_from_preferences,
                        preferences_from_members)


class HasPrefPlugin(Plugin):
    """ Base class for plugin using preferences.

    Simply defines the most basic preferences system inherited from
    HasPrefAtom. Preferences are automatically queried and saved using the
    ecpy.app.preferences plugin.

    """

    update_members_from_preferences = update_members_from_preferences

    preferences_from_members = preferences_from_members

    def start(self):
        """Upon starting initialize members using preferences.

        """
        core = self.workbench.get_plugin('enaml.workbench.core')

        prefs = core.invoke_command('ecpy.app.preferences.get_plugin_prefs',
                                    {'plugin_id': self.manifest.id}, self)

        self.update_members_from_preferences(prefs)
        core.invoke_command('ecpy.app.preferences.plugin_init_complete',
                            {'plugin_id': self.manifest.id}, self)


class ExtensionsCollector(Atom):
    """Convenience class collecting an extension point contribution.

    This class can be used on any extension point to which extensions
    contribute instances of a specific class. Those object should always have
    an id member.

    """
    #: Refrence to the application workbench.
    workbench = Typed(Workbench)

    #: Id of the extension point to observe.
    point = Unicode()

    #: Expected class of the object generated by the extension.
    ext_class = Value()

    #: Callable to use to ensure that the provide extension does fit.
    #: Should return a bool indicating the result of the test, and a message
    #: explaining what went wrong (or an empty string if test passed).
    validate_ext = Callable()

    #: Dictionary storing the constribution of the observed extension point.
    #: This should not be altered by user code.
    contributions = Dict()

    def start(self):
        """Run first collections of contributions and set up observers.

        This method should be called in the start method of the plugin using
        this object.

        """
        self._refresh_contributions()
        self._bind_observers()

    def stop(self):
        """Unbind observers and clean up ressources.

        This method should be called in the stop method of the plugin using
        this object.

        """
        self._unbind_observers()
        self.contributions.clear()
        self._extensions.clear()

    # --- Private API ---------------------------------------------------------

    #: Private storage keeping track of which extension declared which object.
    _extensions = Typed(defaultdict, ())

    def _refresh_contributions(self):
        """ Refresh the extensions contributions.

        This method should be called in the start method of the plugin using
        this object.

        """
        name = self.point.split('.')[-1]
        workbench = self.workbench
        point = workbench.get_extension_point(self.point)
        extensions = point.extensions

        # If no extension remain clear everything
        if not extensions:
            self.contributions.clear()
            self._extensions.clear()
            return

        # Get the engines declarations for all extensions.
        new_extensions = defaultdict(list)
        old_extensions = self._extensions
        for extension in extensions:
            if extension in old_extensions:
                contribs = old_extensions[extension]
            else:
                contribs = self._load_contributions(extension)
            new_extensions[extension].extend(contribs)

        # Create mapping between engine id and declaration.
        contribs = {}
        for extension in extensions:
            for contrib in new_extensions[extension]:
                if contrib.id in contribs:
                    msg = "{} '{}' is already registered"
                    raise ValueError(msg.format(name, contrib.id))
                res, msg = self.validate_ext(contrib)
                if not res:
                    raise ValueError(msg)
                contribs[contrib.id] = contrib

        self.contributions = contribs
        self._extensions = new_extensions

    def _load_contributions(self, extension):
        """ Load the contributed objects for the given extension.

        Parameters
        ----------
        extension : Extension
            The extension object of interest.

        Returns
        -------
        contribs : list
            The objects declared by the extension.

        """
        workbench = self.workbench
        contribs = extension.get_children(self.ext_class)
        if extension.factory is not None and not contribs:
            for contrib in extension.factory(workbench):
                if not isinstance(contrib, self.ext_class):
                    msg = "extension '{}' created non-{}."
                    raise TypeError(msg.format(extension.qualified_id,
                                               self.ext_class.__name__))
                contribs.append(contrib)

        return contribs

    def _on_contribs_updated(self, change):
        """ The observer for the extension point

        """
        self._refresh_contributions()

    def _bind_observers(self):
        """ Setup the observers for the extension point.

        This method should be called in the start method of the plugin using
        this object.

        """
        workbench = self.workbench
        point = workbench.get_extension_point(self.point)
        point.observe('extensions', self._on_contribs_updated)

    def _unbind_observers(self):
        """ Remove the observers for the plugin.

        This method should be called in the stop method of the plugin using
        this object.

        """
        workbench = self.workbench
        point = workbench.get_extension_point(self.point)
        point.unobserve('extensions', self._on_closing_checks_updated)
