# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# Copyright 2015 by Ecpy Authors, see AUTHORS for more details.
#
# Distributed under the terms of the BSD license.
#
# The full license is in the file LICENCE, distributed with this software.
# -----------------------------------------------------------------------------
"""Dummy contributions to the measure plugin used for testing purposes.

"""
from __future__ import (division, unicode_literals, print_function,
                        absolute_import)

from enaml.workbench.api import PluginManifest, Extension
from ecpy.app.dependencies.api import BuildDependency, RuntimeDependency
from ecpy.measure.editors.api import Editor
from ecpy.measure.hooks.api import PreExecutionHook, PostExecutionHook
from ecpy.measure.engines.api import Engine
from ecpy.measure.monitors.api import Monitor, BaseMonitorItem


from enaml.widgets.api import Container, Field
class Flags(object):

    BUILD_FAIL_ANALYSE = False

    BUILD_FAIL_COLLECT = False

    RUNTIME1_FAIL_ANALYSE = False

    RUNTIME2_FAIL_ANALYSE = False

    RUNTIME1_UNAVAILABLE = False

    RUNTIME1_FAIL_COLLECT = False

    RUNTIME2_UNAVAILABLE = False

    RUNTIME2_FAIL_COLLECT = False

    MONITOR_FAIL_WIDGET = False


enamldef MonitorTestItem(BaseMonitorItem):
    Container:
        Field:
            pass


enamldef MeasureTestManifest(PluginManifest):
    """Manifest contributing dummy extensions to measure plugin.

    """
    id = 'test.measure'

    Extension:
        id = 'editor'
        point = 'ecpy.measure.editors'
        Editor:
            id = 'dummy'
            description = 'This is a dummy'
            new => (workbench, default=True):
                from .dummies import DummyEditor
                return DummyEditor(declaration=self)

            is_meant_for => (workbench, selected_task):
                return True

    Extension:
        id = 'engines'
        point = 'ecpy.measure.engines'
        Engine:
            id = 'dummy'
            description = 'This is a dummy'

            attr selected
            attr workspace_contributing
            new => (workbench, default=True):
                from .dummies import DummyEngine
                return DummyEngine(declaration=self)

            react_to_selection => (workbench):
                self.selected = True

            react_to_unselection => (workbench):
                self.selected = False

            contribute_to_workspace => (workspace):
                self.workspace_contributing = True

            clean_workspace => (workspace):
                self.workspace_conytributing = False

    Extension:
        id = 'pre-hook'
        point = 'ecpy.measure.pre-execution'
        PreExecutionHook:
            id = 'dummy'
            description = 'This is a dummy'
            new => (workbench, default=True):
                from .dummies import DummyPreHook
                return DummyPreHook(declaration=self)

    Extension:
        id = 'monitors'
        point = 'ecpy.measure.monitors'
        Monitor:
            id  = 'dummy'
            description = 'This is a dummy'
            new => (workbench, default=True):
                from .dummies import DummyMonitor
                return DummyMonitor(declaration=self)

            create_item => (workbench, area):
                if Flags.MONITOR_FAIL_WIDGET:
                    raise RuntimeError()
                return MonitorTestItem(area)

    Extension:
        id = 'post-hook'
        point = 'ecpy.measure.post-execution'
        PostExecutionHook:
            id = 'dummy'
            description = 'This is a dummy'
            new => (workbench, default=True):
                from .dummies import DummyPostHook
                return DummyPostHook(declaration=self)

    Extension:
        id = 'build-dep'
        point = 'ecpy.app.dependencies.build'
        BuildDependency:
            id = 'dummy'
            analyse => (workbench, obj, getter, dependencies, errors):
                if Flags.BUILD_FAIL_ANALYSE:
                    raise Exception()
                else:
                    dependencies.add('test')
                    return ['dummy1']
            collect => (workbench, dependencies, errors):
                if Flags.BUILD_FAIL_COLLECT:
                    raise Exception()
                else:
                    dependencies['test'] = 1

    Extension:
        id = 'runtime-dep'
        point = 'ecpy.app.dependencies.runtime'
        RuntimeDependency:
            name = 'runtime_dummy1'
            id = 'dummy1'
            attr collected
            analyse => (workbench, obj, getter, dependencies, errors):
                if Flags.RUNTIME1_FAIL_ANALYSE:
                    raise Exception()
                else:
                    dependencies.add('test')
            collect => (workbench, owner, dependencies, unavailable, errors):
                if Flags.RUNTIME1_FAIL_COLLECT:
                    raise Exception()
                elif Flags.RUNTIME1_UNAVAILABLE:
                    unavailable.add('test')
                else:
                    self.collected = True
                    dependencies['test'] = 1
            release => (workbench, owner, dependencies):
                self.collected = False
                if 'test' in dependencies:
                    dependencies['test'] = None

    Extension:
        id = 'runtime-dep2'
        point = 'ecpy.app.dependencies.runtime'
        RuntimeDependency:
            name = 'runtime_dummy2'
            id = 'dummy2'
            attr collected
            collect => (workbench, owner, dependencies, unavailable, errors):
                if Flags.RUNTIME2_FAIL_COLLECT:
                    raise Exception()
                elif Flags.RUNTIME2_UNAVAILABLE:
                    print('t')
                    unavailable.add('test')
                else:
                    self.collected = True
                    dependencies['test'] = 1
            release => (workbench, owner, dependencies):
                self.collected = False
                if 'test' in dependencies:
                    dependencies['test'] = None
